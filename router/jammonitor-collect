#!/bin/sh
# JamMonitor Historical Metrics Collector v4
# Collects metrics every MINUTE (not second) to minimize storage
# 24h = ~1,440 entries (~300KB) vs previous ~86,400 entries (~18MB)

DB_PATH="/mnt/data/jammonitor/history.db"
LOG_PATH="/mnt/data/jammonitor/syslog.txt"
RETENTION_DAYS=30
MAX_LOG_SIZE=104857600  # 100MB max syslog size
WAN_CONFIG="/etc/jammonitor_wans"

# Ensure data directory exists
mkdir -p /mnt/data/jammonitor 2>/dev/null || {
    logger -t jammonitor "FATAL: Cannot create data directory /mnt/data/jammonitor"
    exit 1
}

# Helper: Escape single quotes for SQLite (double them)
sql_escape() {
    printf '%s' "$1" | sed "s/'/''/g"
}

# Get WAN interface list (dynamic or fallback)
get_wan_list() {
    if [ -f "$WAN_CONFIG" ]; then
        cat "$WAN_CONFIG" | tr '\n' ' '
    else
        echo "wan wan1 wan2 wan3 wan4"
    fi
}

# Initialize database with all tables and WAL mode
init_db() {
    sqlite3 "$DB_PATH" "
        PRAGMA journal_mode=WAL;
        PRAGMA busy_timeout=5000;
        CREATE TABLE IF NOT EXISTS metrics (
            ts INTEGER PRIMARY KEY,
            load TEXT,
            ram_pct REAL,
            temp INTEGER,
            wan_pings TEXT,
            iface_status TEXT
        );
        CREATE TABLE IF NOT EXISTS snapshots (
            ts INTEGER PRIMARY KEY,
            mptcp TEXT,
            vpn TEXT,
            routes TEXT,
            conntrack_count INTEGER,
            dns TEXT
        );
        CREATE INDEX IF NOT EXISTS idx_metrics_ts ON metrics(ts);
        CREATE INDEX IF NOT EXISTS idx_snapshots_ts ON snapshots(ts);
    "
}

# Collect metrics (every minute)
collect_metrics() {
    TS=$(date +%s)
    LOAD=$(cat /proc/loadavg | cut -d' ' -f1-3)
    RAM=$(free | awk '/Mem:/{printf "%.1f", $3/$2*100}')
    TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null || echo 0)

    # Pings with timeout protection
    P1=$(timeout 2 ping -c1 -W1 1.1.1.1 2>/dev/null | grep -oE 'time=[0-9.]+' | cut -d= -f2)
    P2=$(timeout 2 ping -c1 -W1 8.8.8.8 2>/dev/null | grep -oE 'time=[0-9.]+' | cut -d= -f2)
    [ -z "$P1" ] && P1="null"
    [ -z "$P2" ] && P2="null"
    PINGS="{\"1.1.1.1\":$P1,\"8.8.8.8\":$P2}"

    # Interface status (dynamic list)
    IFACES="{"
    FIRST=1
    for iface in $(get_wan_list); do
        UP=$(timeout 2 ifstatus $iface 2>/dev/null | jsonfilter -e '@.up' 2>/dev/null)
        [ $FIRST -eq 0 ] && IFACES="$IFACES,"
        [ "$UP" = "true" ] && IFACES="$IFACES\"$iface\":1" || IFACES="$IFACES\"$iface\":0"
        FIRST=0
    done
    IFACES="$IFACES}"

    # Escape values for SQL safety
    LOAD_ESC=$(sql_escape "$LOAD")
    PINGS_ESC=$(sql_escape "$PINGS")
    IFACES_ESC=$(sql_escape "$IFACES")

    sqlite3 "$DB_PATH" "INSERT OR REPLACE INTO metrics VALUES ($TS, '$LOAD_ESC', $RAM, $TEMP, '$PINGS_ESC', '$IFACES_ESC');" 2>/dev/null
}

# Collect slow snapshots (every minute)
collect_slow() {
    TS=$(date +%s)

    # MPTCP endpoints and limits (with timeout)
    MPTCP_EP=$(timeout 5 ip mptcp endpoint show 2>/dev/null | head -20 | tr '\n' '|')
    MPTCP_LIM=$(timeout 2 ip mptcp limits 2>/dev/null | tr '\n' '|')
    MPTCP="$MPTCP_EP;;$MPTCP_LIM"

    # VPN status (simplified)
    VPN=""
    if command -v wg >/dev/null 2>&1; then
        VPN=$(timeout 2 wg show interfaces 2>/dev/null | tr '\n' ',')
    fi
    GT=$(pgrep -c glorytun 2>/dev/null || echo 0)
    OV=$(pgrep -c openvpn 2>/dev/null || echo 0)
    VPN="wg:$VPN|gt:$GT|ovpn:$OV"

    # Routes summary (default routes only)
    ROUTES=$(ip route show default 2>/dev/null | head -10 | tr '\n' '|')

    # Conntrack count
    CT_COUNT=$(cat /proc/sys/net/netfilter/nf_conntrack_count 2>/dev/null || echo 0)

    # DNS servers
    DNS=$(grep nameserver /tmp/resolv.conf 2>/dev/null | awk '{print $2}' | tr '\n' ',' | sed 's/,$//')

    # Escape all values for SQL safety
    MPTCP_ESC=$(sql_escape "$MPTCP")
    VPN_ESC=$(sql_escape "$VPN")
    ROUTES_ESC=$(sql_escape "$ROUTES")
    DNS_ESC=$(sql_escape "$DNS")

    sqlite3 "$DB_PATH" "INSERT OR REPLACE INTO snapshots VALUES ($TS, '$MPTCP_ESC', '$VPN_ESC', '$ROUTES_ESC', $CT_COUNT, '$DNS_ESC');" 2>/dev/null
}

# Stream syslog (continuous append with rotation)
stream_syslog() {
    # Rotate if too big
    if [ -f "$LOG_PATH" ]; then
        SIZE=$(stat -c%s "$LOG_PATH" 2>/dev/null || stat -f%z "$LOG_PATH" 2>/dev/null || echo 0)
        if [ "$SIZE" -gt "$MAX_LOG_SIZE" ]; then
            mv "$LOG_PATH" "${LOG_PATH}.old"
        fi
    fi

    # Append recent syslog entries (last 100 lines since last check)
    logread 2>/dev/null | tail -100 >> "$LOG_PATH"
}

# Cleanup old data
cleanup() {
    CUTOFF=$(($(date +%s) - RETENTION_DAYS * 86400))
    sqlite3 "$DB_PATH" "DELETE FROM metrics WHERE ts < $CUTOFF;"
    sqlite3 "$DB_PATH" "DELETE FROM snapshots WHERE ts < $CUTOFF;"

    # Cleanup old syslog
    if [ -f "${LOG_PATH}.old" ]; then
        OLDTIME=$(stat -c%Y "${LOG_PATH}.old" 2>/dev/null || stat -f%m "${LOG_PATH}.old" 2>/dev/null || echo 0)
        NOW=$(date +%s)
        if [ $((NOW - OLDTIME)) -gt $((RETENTION_DAYS * 86400)) ]; then
            rm -f "${LOG_PATH}.old"
        fi
    fi
}

# Main
init_db

COUNTER=0

while true; do
    # Collect metrics and snapshots every minute
    collect_metrics
    collect_slow
    stream_syslog

    COUNTER=$((COUNTER + 1))

    # Cleanup every hour (60 iterations)
    if [ $COUNTER -ge 60 ]; then
        cleanup
        COUNTER=0
    fi

    sleep 60
done
